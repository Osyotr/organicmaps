// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: drules_struct.proto
// Protobuf C++ Version: 5.29.3

#ifndef drules_5fstruct_2eproto_2epb_2eh
#define drules_5fstruct_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_drules_5fstruct_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_drules_5fstruct_2eproto {
  static const ::uint32_t offsets[];
};
class AreaRuleProto;
struct AreaRuleProtoDefaultTypeInternal;
extern AreaRuleProtoDefaultTypeInternal _AreaRuleProto_default_instance_;
class CaptionDefProto;
struct CaptionDefProtoDefaultTypeInternal;
extern CaptionDefProtoDefaultTypeInternal _CaptionDefProto_default_instance_;
class CaptionRuleProto;
struct CaptionRuleProtoDefaultTypeInternal;
extern CaptionRuleProtoDefaultTypeInternal _CaptionRuleProto_default_instance_;
class CircleRuleProto;
struct CircleRuleProtoDefaultTypeInternal;
extern CircleRuleProtoDefaultTypeInternal _CircleRuleProto_default_instance_;
class ClassifElementProto;
struct ClassifElementProtoDefaultTypeInternal;
extern ClassifElementProtoDefaultTypeInternal _ClassifElementProto_default_instance_;
class ColorElementProto;
struct ColorElementProtoDefaultTypeInternal;
extern ColorElementProtoDefaultTypeInternal _ColorElementProto_default_instance_;
class ColorsElementProto;
struct ColorsElementProtoDefaultTypeInternal;
extern ColorsElementProtoDefaultTypeInternal _ColorsElementProto_default_instance_;
class ContainerProto;
struct ContainerProtoDefaultTypeInternal;
extern ContainerProtoDefaultTypeInternal _ContainerProto_default_instance_;
class DashDotProto;
struct DashDotProtoDefaultTypeInternal;
extern DashDotProtoDefaultTypeInternal _DashDotProto_default_instance_;
class DrawElementProto;
struct DrawElementProtoDefaultTypeInternal;
extern DrawElementProtoDefaultTypeInternal _DrawElementProto_default_instance_;
class LineDefProto;
struct LineDefProtoDefaultTypeInternal;
extern LineDefProtoDefaultTypeInternal _LineDefProto_default_instance_;
class LineRuleProto;
struct LineRuleProtoDefaultTypeInternal;
extern LineRuleProtoDefaultTypeInternal _LineRuleProto_default_instance_;
class PathSymProto;
struct PathSymProtoDefaultTypeInternal;
extern PathSymProtoDefaultTypeInternal _PathSymProto_default_instance_;
class PathTextRuleProto;
struct PathTextRuleProtoDefaultTypeInternal;
extern PathTextRuleProtoDefaultTypeInternal _PathTextRuleProto_default_instance_;
class ShieldRuleProto;
struct ShieldRuleProtoDefaultTypeInternal;
extern ShieldRuleProtoDefaultTypeInternal _ShieldRuleProto_default_instance_;
class SymbolRuleProto;
struct SymbolRuleProtoDefaultTypeInternal;
extern SymbolRuleProtoDefaultTypeInternal _SymbolRuleProto_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum LineJoin : int {
  ROUNDJOIN = 0,
  BEVELJOIN = 1,
  NOJOIN = 2,
  LineJoin_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LineJoin_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LineJoin_IsValid(int value);
extern const uint32_t LineJoin_internal_data_[];
constexpr LineJoin LineJoin_MIN = static_cast<LineJoin>(0);
constexpr LineJoin LineJoin_MAX = static_cast<LineJoin>(2);
constexpr int LineJoin_ARRAYSIZE = 2 + 1;
const std::string& LineJoin_Name(LineJoin value);
template <typename T>
const std::string& LineJoin_Name(T value) {
  static_assert(std::is_same<T, LineJoin>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LineJoin_Name().");
  return LineJoin_Name(static_cast<LineJoin>(value));
}
bool LineJoin_Parse(absl::string_view name, LineJoin* value);
enum LineCap : int {
  ROUNDCAP = 0,
  BUTTCAP = 1,
  SQUARECAP = 2,
  LineCap_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LineCap_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LineCap_IsValid(int value);
extern const uint32_t LineCap_internal_data_[];
constexpr LineCap LineCap_MIN = static_cast<LineCap>(0);
constexpr LineCap LineCap_MAX = static_cast<LineCap>(2);
constexpr int LineCap_ARRAYSIZE = 2 + 1;
const std::string& LineCap_Name(LineCap value);
template <typename T>
const std::string& LineCap_Name(T value) {
  static_assert(std::is_same<T, LineCap>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LineCap_Name().");
  return LineCap_Name(static_cast<LineCap>(value));
}
bool LineCap_Parse(absl::string_view name, LineCap* value);

// ===================================================================


// -------------------------------------------------------------------

class SymbolRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:SymbolRuleProto) */ {
 public:
  inline SymbolRuleProto() : SymbolRuleProto(nullptr) {}
  ~SymbolRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SymbolRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SymbolRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SymbolRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline SymbolRuleProto(const SymbolRuleProto& from) : SymbolRuleProto(nullptr, from) {}
  inline SymbolRuleProto(SymbolRuleProto&& from) noexcept
      : SymbolRuleProto(nullptr, std::move(from)) {}
  inline SymbolRuleProto& operator=(const SymbolRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolRuleProto& operator=(SymbolRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SymbolRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolRuleProto* internal_default_instance() {
    return reinterpret_cast<const SymbolRuleProto*>(
        &_SymbolRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SymbolRuleProto& a, SymbolRuleProto& b) { a.Swap(&b); }
  inline void Swap(SymbolRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SymbolRuleProto>(arena);
  }
  void CopyFrom(const SymbolRuleProto& from);
  void MergeFrom(const SymbolRuleProto& from) { SymbolRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SymbolRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "SymbolRuleProto"; }

 protected:
  explicit SymbolRuleProto(::google::protobuf::Arena* arena);
  SymbolRuleProto(::google::protobuf::Arena* arena, const SymbolRuleProto& from);
  SymbolRuleProto(::google::protobuf::Arena* arena, SymbolRuleProto&& from) noexcept
      : SymbolRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<16> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kApplyForTypeFieldNumber = 2,
    kPriorityFieldNumber = 3,
    kMinDistanceFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 apply_for_type = 2;
  void clear_apply_for_type() ;
  ::int32_t apply_for_type() const;
  void set_apply_for_type(::int32_t value);

  private:
  ::int32_t _internal_apply_for_type() const;
  void _internal_set_apply_for_type(::int32_t value);

  public:
  // int32 priority = 3;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // int32 min_distance = 4;
  void clear_min_distance() ;
  ::int32_t min_distance() const;
  void set_min_distance(::int32_t value);

  private:
  ::int32_t _internal_min_distance() const;
  void _internal_set_min_distance(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SymbolRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      28, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SymbolRuleProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t apply_for_type_;
    ::int32_t priority_;
    ::int32_t min_distance_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class ShieldRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ShieldRuleProto) */ {
 public:
  inline ShieldRuleProto() : ShieldRuleProto(nullptr) {}
  ~ShieldRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ShieldRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ShieldRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShieldRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShieldRuleProto(const ShieldRuleProto& from) : ShieldRuleProto(nullptr, from) {}
  inline ShieldRuleProto(ShieldRuleProto&& from) noexcept
      : ShieldRuleProto(nullptr, std::move(from)) {}
  inline ShieldRuleProto& operator=(const ShieldRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShieldRuleProto& operator=(ShieldRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShieldRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShieldRuleProto* internal_default_instance() {
    return reinterpret_cast<const ShieldRuleProto*>(
        &_ShieldRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ShieldRuleProto& a, ShieldRuleProto& b) { a.Swap(&b); }
  inline void Swap(ShieldRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShieldRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShieldRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ShieldRuleProto>(arena);
  }
  void CopyFrom(const ShieldRuleProto& from);
  void MergeFrom(const ShieldRuleProto& from) { ShieldRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ShieldRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ShieldRuleProto"; }

 protected:
  explicit ShieldRuleProto(::google::protobuf::Arena* arena);
  ShieldRuleProto(::google::protobuf::Arena* arena, const ShieldRuleProto& from);
  ShieldRuleProto(::google::protobuf::Arena* arena, ShieldRuleProto&& from) noexcept
      : ShieldRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<16> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeightFieldNumber = 1,
    kColorFieldNumber = 2,
    kStrokeColorFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kMinDistanceFieldNumber = 5,
    kTextColorFieldNumber = 6,
    kTextStrokeColorFieldNumber = 7,
  };
  // int32 height = 1;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // uint32 stroke_color = 3;
  void clear_stroke_color() ;
  ::uint32_t stroke_color() const;
  void set_stroke_color(::uint32_t value);

  private:
  ::uint32_t _internal_stroke_color() const;
  void _internal_set_stroke_color(::uint32_t value);

  public:
  // int32 priority = 4;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // int32 min_distance = 5;
  void clear_min_distance() ;
  ::int32_t min_distance() const;
  void set_min_distance(::int32_t value);

  private:
  ::int32_t _internal_min_distance() const;
  void _internal_set_min_distance(::int32_t value);

  public:
  // uint32 text_color = 6;
  void clear_text_color() ;
  ::uint32_t text_color() const;
  void set_text_color(::uint32_t value);

  private:
  ::uint32_t _internal_text_color() const;
  void _internal_set_text_color(::uint32_t value);

  public:
  // uint32 text_stroke_color = 7;
  void clear_text_stroke_color() ;
  ::uint32_t text_stroke_color() const;
  void set_text_stroke_color(::uint32_t value);

  private:
  ::uint32_t _internal_text_stroke_color() const;
  void _internal_set_text_stroke_color(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ShieldRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ShieldRuleProto& from_msg);
    ::int32_t height_;
    ::uint32_t color_;
    ::uint32_t stroke_color_;
    ::int32_t priority_;
    ::int32_t min_distance_;
    ::uint32_t text_color_;
    ::uint32_t text_stroke_color_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class PathSymProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:PathSymProto) */ {
 public:
  inline PathSymProto() : PathSymProto(nullptr) {}
  ~PathSymProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PathSymProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PathSymProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PathSymProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline PathSymProto(const PathSymProto& from) : PathSymProto(nullptr, from) {}
  inline PathSymProto(PathSymProto&& from) noexcept
      : PathSymProto(nullptr, std::move(from)) {}
  inline PathSymProto& operator=(const PathSymProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSymProto& operator=(PathSymProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PathSymProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSymProto* internal_default_instance() {
    return reinterpret_cast<const PathSymProto*>(
        &_PathSymProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(PathSymProto& a, PathSymProto& b) { a.Swap(&b); }
  inline void Swap(PathSymProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSymProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathSymProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PathSymProto>(arena);
  }
  void CopyFrom(const PathSymProto& from);
  void MergeFrom(const PathSymProto& from) { PathSymProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PathSymProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PathSymProto"; }

 protected:
  explicit PathSymProto(::google::protobuf::Arena* arena);
  PathSymProto(::google::protobuf::Arena* arena, const PathSymProto& from);
  PathSymProto(::google::protobuf::Arena* arena, PathSymProto&& from) noexcept
      : PathSymProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<13> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kStepFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // double step = 2;
  void clear_step() ;
  double step() const;
  void set_step(double value);

  private:
  double _internal_step() const;
  void _internal_set_step(double value);

  public:
  // double offset = 3;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // @@protoc_insertion_point(class_scope:PathSymProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      25, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PathSymProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    double step_;
    double offset_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class DashDotProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:DashDotProto) */ {
 public:
  inline DashDotProto() : DashDotProto(nullptr) {}
  ~DashDotProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DashDotProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DashDotProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DashDotProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline DashDotProto(const DashDotProto& from) : DashDotProto(nullptr, from) {}
  inline DashDotProto(DashDotProto&& from) noexcept
      : DashDotProto(nullptr, std::move(from)) {}
  inline DashDotProto& operator=(const DashDotProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DashDotProto& operator=(DashDotProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DashDotProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DashDotProto* internal_default_instance() {
    return reinterpret_cast<const DashDotProto*>(
        &_DashDotProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(DashDotProto& a, DashDotProto& b) { a.Swap(&b); }
  inline void Swap(DashDotProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DashDotProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DashDotProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DashDotProto>(arena);
  }
  void CopyFrom(const DashDotProto& from);
  void MergeFrom(const DashDotProto& from) { DashDotProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DashDotProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DashDotProto"; }

 protected:
  explicit DashDotProto(::google::protobuf::Arena* arena);
  DashDotProto(::google::protobuf::Arena* arena, const DashDotProto& from);
  DashDotProto(::google::protobuf::Arena* arena, DashDotProto&& from) noexcept
      : DashDotProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<13> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDdFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // repeated double dd = 1;
  int dd_size() const;
  private:
  int _internal_dd_size() const;

  public:
  void clear_dd() ;
  double dd(int index) const;
  void set_dd(int index, double value);
  void add_dd(double value);
  const ::google::protobuf::RepeatedField<double>& dd() const;
  ::google::protobuf::RepeatedField<double>* mutable_dd();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_dd() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_dd();

  public:
  // double offset = 2;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // @@protoc_insertion_point(class_scope:DashDotProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DashDotProto& from_msg);
    ::google::protobuf::RepeatedField<double> dd_;
    double offset_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class ColorElementProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ColorElementProto) */ {
 public:
  inline ColorElementProto() : ColorElementProto(nullptr) {}
  ~ColorElementProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorElementProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorElementProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorElementProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorElementProto(const ColorElementProto& from) : ColorElementProto(nullptr, from) {}
  inline ColorElementProto(ColorElementProto&& from) noexcept
      : ColorElementProto(nullptr, std::move(from)) {}
  inline ColorElementProto& operator=(const ColorElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorElementProto& operator=(ColorElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ColorElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorElementProto* internal_default_instance() {
    return reinterpret_cast<const ColorElementProto*>(
        &_ColorElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ColorElementProto& a, ColorElementProto& b) { a.Swap(&b); }
  inline void Swap(ColorElementProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorElementProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorElementProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ColorElementProto>(arena);
  }
  void CopyFrom(const ColorElementProto& from);
  void MergeFrom(const ColorElementProto& from) { ColorElementProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorElementProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ColorElementProto"; }

 protected:
  explicit ColorElementProto(::google::protobuf::Arena* arena);
  ColorElementProto(::google::protobuf::Arena* arena, const ColorElementProto& from);
  ColorElementProto(::google::protobuf::Arena* arena, ColorElementProto&& from) noexcept
      : ColorElementProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<18> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kColorFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // float x = 3;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 4;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:ColorElementProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      30, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorElementProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t color_;
    float x_;
    float y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class CaptionDefProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:CaptionDefProto) */ {
 public:
  inline CaptionDefProto() : CaptionDefProto(nullptr) {}
  ~CaptionDefProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CaptionDefProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CaptionDefProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CaptionDefProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CaptionDefProto(const CaptionDefProto& from) : CaptionDefProto(nullptr, from) {}
  inline CaptionDefProto(CaptionDefProto&& from) noexcept
      : CaptionDefProto(nullptr, std::move(from)) {}
  inline CaptionDefProto& operator=(const CaptionDefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptionDefProto& operator=(CaptionDefProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CaptionDefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptionDefProto* internal_default_instance() {
    return reinterpret_cast<const CaptionDefProto*>(
        &_CaptionDefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CaptionDefProto& a, CaptionDefProto& b) { a.Swap(&b); }
  inline void Swap(CaptionDefProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptionDefProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptionDefProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CaptionDefProto>(arena);
  }
  void CopyFrom(const CaptionDefProto& from);
  void MergeFrom(const CaptionDefProto& from) { CaptionDefProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CaptionDefProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "CaptionDefProto"; }

 protected:
  explicit CaptionDefProto(::google::protobuf::Arena* arena);
  CaptionDefProto(::google::protobuf::Arena* arena, const CaptionDefProto& from);
  CaptionDefProto(::google::protobuf::Arena* arena, CaptionDefProto&& from) noexcept
      : CaptionDefProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<16> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 6,
    kHeightFieldNumber = 1,
    kColorFieldNumber = 2,
    kStrokeColorFieldNumber = 3,
    kOffsetXFieldNumber = 4,
    kOffsetYFieldNumber = 5,
    kIsOptionalFieldNumber = 7,
  };
  // string text = 6;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // int32 height = 1;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // uint32 stroke_color = 3;
  void clear_stroke_color() ;
  ::uint32_t stroke_color() const;
  void set_stroke_color(::uint32_t value);

  private:
  ::uint32_t _internal_stroke_color() const;
  void _internal_set_stroke_color(::uint32_t value);

  public:
  // int32 offset_x = 4;
  void clear_offset_x() ;
  ::int32_t offset_x() const;
  void set_offset_x(::int32_t value);

  private:
  ::int32_t _internal_offset_x() const;
  void _internal_set_offset_x(::int32_t value);

  public:
  // int32 offset_y = 5;
  void clear_offset_y() ;
  ::int32_t offset_y() const;
  void set_offset_y(::int32_t value);

  private:
  ::int32_t _internal_offset_y() const;
  void _internal_set_offset_y(::int32_t value);

  public:
  // bool is_optional = 7;
  void clear_is_optional() ;
  bool is_optional() const;
  void set_is_optional(bool value);

  private:
  bool _internal_is_optional() const;
  void _internal_set_is_optional(bool value);

  public:
  // @@protoc_insertion_point(class_scope:CaptionDefProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      28, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CaptionDefProto& from_msg);
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::int32_t height_;
    ::uint32_t color_;
    ::uint32_t stroke_color_;
    ::int32_t offset_x_;
    ::int32_t offset_y_;
    bool is_optional_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class PathTextRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:PathTextRuleProto) */ {
 public:
  inline PathTextRuleProto() : PathTextRuleProto(nullptr) {}
  ~PathTextRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PathTextRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PathTextRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PathTextRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline PathTextRuleProto(const PathTextRuleProto& from) : PathTextRuleProto(nullptr, from) {}
  inline PathTextRuleProto(PathTextRuleProto&& from) noexcept
      : PathTextRuleProto(nullptr, std::move(from)) {}
  inline PathTextRuleProto& operator=(const PathTextRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathTextRuleProto& operator=(PathTextRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PathTextRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathTextRuleProto* internal_default_instance() {
    return reinterpret_cast<const PathTextRuleProto*>(
        &_PathTextRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(PathTextRuleProto& a, PathTextRuleProto& b) { a.Swap(&b); }
  inline void Swap(PathTextRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathTextRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathTextRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PathTextRuleProto>(arena);
  }
  void CopyFrom(const PathTextRuleProto& from);
  void MergeFrom(const PathTextRuleProto& from) { PathTextRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PathTextRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "PathTextRuleProto"; }

 protected:
  explicit PathTextRuleProto(::google::protobuf::Arena* arena);
  PathTextRuleProto(::google::protobuf::Arena* arena, const PathTextRuleProto& from);
  PathTextRuleProto(::google::protobuf::Arena* arena, PathTextRuleProto&& from) noexcept
      : PathTextRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<18> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrimaryFieldNumber = 1,
    kSecondaryFieldNumber = 2,
    kPriorityFieldNumber = 3,
  };
  // .CaptionDefProto primary = 1;
  bool has_primary() const;
  void clear_primary() ;
  const ::CaptionDefProto& primary() const;
  PROTOBUF_NODISCARD ::CaptionDefProto* release_primary();
  ::CaptionDefProto* mutable_primary();
  void set_allocated_primary(::CaptionDefProto* value);
  void unsafe_arena_set_allocated_primary(::CaptionDefProto* value);
  ::CaptionDefProto* unsafe_arena_release_primary();

  private:
  const ::CaptionDefProto& _internal_primary() const;
  ::CaptionDefProto* _internal_mutable_primary();

  public:
  // .CaptionDefProto secondary = 2;
  bool has_secondary() const;
  void clear_secondary() ;
  const ::CaptionDefProto& secondary() const;
  PROTOBUF_NODISCARD ::CaptionDefProto* release_secondary();
  ::CaptionDefProto* mutable_secondary();
  void set_allocated_secondary(::CaptionDefProto* value);
  void unsafe_arena_set_allocated_secondary(::CaptionDefProto* value);
  ::CaptionDefProto* unsafe_arena_release_secondary();

  private:
  const ::CaptionDefProto& _internal_secondary() const;
  ::CaptionDefProto* _internal_mutable_secondary();

  public:
  // int32 priority = 3;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PathTextRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PathTextRuleProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::CaptionDefProto* primary_;
    ::CaptionDefProto* secondary_;
    ::int32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class LineRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:LineRuleProto) */ {
 public:
  inline LineRuleProto() : LineRuleProto(nullptr) {}
  ~LineRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LineRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LineRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LineRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline LineRuleProto(const LineRuleProto& from) : LineRuleProto(nullptr, from) {}
  inline LineRuleProto(LineRuleProto&& from) noexcept
      : LineRuleProto(nullptr, std::move(from)) {}
  inline LineRuleProto& operator=(const LineRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineRuleProto& operator=(LineRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LineRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineRuleProto* internal_default_instance() {
    return reinterpret_cast<const LineRuleProto*>(
        &_LineRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LineRuleProto& a, LineRuleProto& b) { a.Swap(&b); }
  inline void Swap(LineRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<LineRuleProto>(arena);
  }
  void CopyFrom(const LineRuleProto& from);
  void MergeFrom(const LineRuleProto& from) { LineRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LineRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "LineRuleProto"; }

 protected:
  explicit LineRuleProto(::google::protobuf::Arena* arena);
  LineRuleProto(::google::protobuf::Arena* arena, const LineRuleProto& from);
  LineRuleProto(::google::protobuf::Arena* arena, LineRuleProto&& from) noexcept
      : LineRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<14> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDashdotFieldNumber = 3,
    kPathsymFieldNumber = 5,
    kWidthFieldNumber = 1,
    kColorFieldNumber = 2,
    kPriorityFieldNumber = 4,
    kJoinFieldNumber = 6,
    kCapFieldNumber = 7,
  };
  // .DashDotProto dashdot = 3;
  bool has_dashdot() const;
  void clear_dashdot() ;
  const ::DashDotProto& dashdot() const;
  PROTOBUF_NODISCARD ::DashDotProto* release_dashdot();
  ::DashDotProto* mutable_dashdot();
  void set_allocated_dashdot(::DashDotProto* value);
  void unsafe_arena_set_allocated_dashdot(::DashDotProto* value);
  ::DashDotProto* unsafe_arena_release_dashdot();

  private:
  const ::DashDotProto& _internal_dashdot() const;
  ::DashDotProto* _internal_mutable_dashdot();

  public:
  // .PathSymProto pathsym = 5;
  bool has_pathsym() const;
  void clear_pathsym() ;
  const ::PathSymProto& pathsym() const;
  PROTOBUF_NODISCARD ::PathSymProto* release_pathsym();
  ::PathSymProto* mutable_pathsym();
  void set_allocated_pathsym(::PathSymProto* value);
  void unsafe_arena_set_allocated_pathsym(::PathSymProto* value);
  ::PathSymProto* unsafe_arena_release_pathsym();

  private:
  const ::PathSymProto& _internal_pathsym() const;
  ::PathSymProto* _internal_mutable_pathsym();

  public:
  // double width = 1;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // int32 priority = 4;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // .LineJoin join = 6;
  void clear_join() ;
  ::LineJoin join() const;
  void set_join(::LineJoin value);

  private:
  ::LineJoin _internal_join() const;
  void _internal_set_join(::LineJoin value);

  public:
  // .LineCap cap = 7;
  void clear_cap() ;
  ::LineCap cap() const;
  void set_cap(::LineCap value);

  private:
  ::LineCap _internal_cap() const;
  void _internal_set_cap(::LineCap value);

  public:
  // @@protoc_insertion_point(class_scope:LineRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LineRuleProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DashDotProto* dashdot_;
    ::PathSymProto* pathsym_;
    double width_;
    ::uint32_t color_;
    ::int32_t priority_;
    int join_;
    int cap_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class LineDefProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:LineDefProto) */ {
 public:
  inline LineDefProto() : LineDefProto(nullptr) {}
  ~LineDefProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LineDefProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LineDefProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LineDefProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline LineDefProto(const LineDefProto& from) : LineDefProto(nullptr, from) {}
  inline LineDefProto(LineDefProto&& from) noexcept
      : LineDefProto(nullptr, std::move(from)) {}
  inline LineDefProto& operator=(const LineDefProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineDefProto& operator=(LineDefProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LineDefProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineDefProto* internal_default_instance() {
    return reinterpret_cast<const LineDefProto*>(
        &_LineDefProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LineDefProto& a, LineDefProto& b) { a.Swap(&b); }
  inline void Swap(LineDefProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineDefProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineDefProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<LineDefProto>(arena);
  }
  void CopyFrom(const LineDefProto& from);
  void MergeFrom(const LineDefProto& from) { LineDefProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LineDefProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "LineDefProto"; }

 protected:
  explicit LineDefProto(::google::protobuf::Arena* arena);
  LineDefProto(::google::protobuf::Arena* arena, const LineDefProto& from);
  LineDefProto(::google::protobuf::Arena* arena, LineDefProto&& from) noexcept
      : LineDefProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<13> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDashdotFieldNumber = 3,
    kPathsymFieldNumber = 4,
    kWidthFieldNumber = 1,
    kColorFieldNumber = 2,
    kJoinFieldNumber = 6,
    kCapFieldNumber = 7,
  };
  // .DashDotProto dashdot = 3;
  bool has_dashdot() const;
  void clear_dashdot() ;
  const ::DashDotProto& dashdot() const;
  PROTOBUF_NODISCARD ::DashDotProto* release_dashdot();
  ::DashDotProto* mutable_dashdot();
  void set_allocated_dashdot(::DashDotProto* value);
  void unsafe_arena_set_allocated_dashdot(::DashDotProto* value);
  ::DashDotProto* unsafe_arena_release_dashdot();

  private:
  const ::DashDotProto& _internal_dashdot() const;
  ::DashDotProto* _internal_mutable_dashdot();

  public:
  // .PathSymProto pathsym = 4;
  bool has_pathsym() const;
  void clear_pathsym() ;
  const ::PathSymProto& pathsym() const;
  PROTOBUF_NODISCARD ::PathSymProto* release_pathsym();
  ::PathSymProto* mutable_pathsym();
  void set_allocated_pathsym(::PathSymProto* value);
  void unsafe_arena_set_allocated_pathsym(::PathSymProto* value);
  ::PathSymProto* unsafe_arena_release_pathsym();

  private:
  const ::PathSymProto& _internal_pathsym() const;
  ::PathSymProto* _internal_mutable_pathsym();

  public:
  // double width = 1;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // .LineJoin join = 6;
  void clear_join() ;
  ::LineJoin join() const;
  void set_join(::LineJoin value);

  private:
  ::LineJoin _internal_join() const;
  void _internal_set_join(::LineJoin value);

  public:
  // .LineCap cap = 7;
  void clear_cap() ;
  ::LineCap cap() const;
  void set_cap(::LineCap value);

  private:
  ::LineCap _internal_cap() const;
  void _internal_set_cap(::LineCap value);

  public:
  // @@protoc_insertion_point(class_scope:LineDefProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LineDefProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::DashDotProto* dashdot_;
    ::PathSymProto* pathsym_;
    double width_;
    ::uint32_t color_;
    int join_;
    int cap_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class ColorsElementProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ColorsElementProto) */ {
 public:
  inline ColorsElementProto() : ColorsElementProto(nullptr) {}
  ~ColorsElementProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorsElementProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorsElementProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorsElementProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorsElementProto(const ColorsElementProto& from) : ColorsElementProto(nullptr, from) {}
  inline ColorsElementProto(ColorsElementProto&& from) noexcept
      : ColorsElementProto(nullptr, std::move(from)) {}
  inline ColorsElementProto& operator=(const ColorsElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorsElementProto& operator=(ColorsElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ColorsElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorsElementProto* internal_default_instance() {
    return reinterpret_cast<const ColorsElementProto*>(
        &_ColorsElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ColorsElementProto& a, ColorsElementProto& b) { a.Swap(&b); }
  inline void Swap(ColorsElementProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorsElementProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorsElementProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ColorsElementProto>(arena);
  }
  void CopyFrom(const ColorsElementProto& from);
  void MergeFrom(const ColorsElementProto& from) { ColorsElementProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorsElementProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ColorsElementProto"; }

 protected:
  explicit ColorsElementProto(::google::protobuf::Arena* arena);
  ColorsElementProto(::google::protobuf::Arena* arena, const ColorsElementProto& from);
  ColorsElementProto(::google::protobuf::Arena* arena, ColorsElementProto&& from) noexcept
      : ColorsElementProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<19> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .ColorElementProto value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  ::ColorElementProto* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField<::ColorElementProto>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<::ColorElementProto>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<::ColorElementProto>* _internal_mutable_value();
  public:
  const ::ColorElementProto& value(int index) const;
  ::ColorElementProto* add_value();
  const ::google::protobuf::RepeatedPtrField<::ColorElementProto>& value() const;
  // @@protoc_insertion_point(class_scope:ColorsElementProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorsElementProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::ColorElementProto > value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class CaptionRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:CaptionRuleProto) */ {
 public:
  inline CaptionRuleProto() : CaptionRuleProto(nullptr) {}
  ~CaptionRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CaptionRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CaptionRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CaptionRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CaptionRuleProto(const CaptionRuleProto& from) : CaptionRuleProto(nullptr, from) {}
  inline CaptionRuleProto(CaptionRuleProto&& from) noexcept
      : CaptionRuleProto(nullptr, std::move(from)) {}
  inline CaptionRuleProto& operator=(const CaptionRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptionRuleProto& operator=(CaptionRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CaptionRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptionRuleProto* internal_default_instance() {
    return reinterpret_cast<const CaptionRuleProto*>(
        &_CaptionRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CaptionRuleProto& a, CaptionRuleProto& b) { a.Swap(&b); }
  inline void Swap(CaptionRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptionRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptionRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CaptionRuleProto>(arena);
  }
  void CopyFrom(const CaptionRuleProto& from);
  void MergeFrom(const CaptionRuleProto& from) { CaptionRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CaptionRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "CaptionRuleProto"; }

 protected:
  explicit CaptionRuleProto(::google::protobuf::Arena* arena);
  CaptionRuleProto(::google::protobuf::Arena* arena, const CaptionRuleProto& from);
  CaptionRuleProto(::google::protobuf::Arena* arena, CaptionRuleProto&& from) noexcept
      : CaptionRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<17> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrimaryFieldNumber = 1,
    kSecondaryFieldNumber = 2,
    kPriorityFieldNumber = 3,
  };
  // .CaptionDefProto primary = 1;
  bool has_primary() const;
  void clear_primary() ;
  const ::CaptionDefProto& primary() const;
  PROTOBUF_NODISCARD ::CaptionDefProto* release_primary();
  ::CaptionDefProto* mutable_primary();
  void set_allocated_primary(::CaptionDefProto* value);
  void unsafe_arena_set_allocated_primary(::CaptionDefProto* value);
  ::CaptionDefProto* unsafe_arena_release_primary();

  private:
  const ::CaptionDefProto& _internal_primary() const;
  ::CaptionDefProto* _internal_mutable_primary();

  public:
  // .CaptionDefProto secondary = 2;
  bool has_secondary() const;
  void clear_secondary() ;
  const ::CaptionDefProto& secondary() const;
  PROTOBUF_NODISCARD ::CaptionDefProto* release_secondary();
  ::CaptionDefProto* mutable_secondary();
  void set_allocated_secondary(::CaptionDefProto* value);
  void unsafe_arena_set_allocated_secondary(::CaptionDefProto* value);
  ::CaptionDefProto* unsafe_arena_release_secondary();

  private:
  const ::CaptionDefProto& _internal_secondary() const;
  ::CaptionDefProto* _internal_mutable_secondary();

  public:
  // int32 priority = 3;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CaptionRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CaptionRuleProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::CaptionDefProto* primary_;
    ::CaptionDefProto* secondary_;
    ::int32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class CircleRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:CircleRuleProto) */ {
 public:
  inline CircleRuleProto() : CircleRuleProto(nullptr) {}
  ~CircleRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CircleRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CircleRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CircleRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline CircleRuleProto(const CircleRuleProto& from) : CircleRuleProto(nullptr, from) {}
  inline CircleRuleProto(CircleRuleProto&& from) noexcept
      : CircleRuleProto(nullptr, std::move(from)) {}
  inline CircleRuleProto& operator=(const CircleRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleRuleProto& operator=(CircleRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CircleRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircleRuleProto* internal_default_instance() {
    return reinterpret_cast<const CircleRuleProto*>(
        &_CircleRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CircleRuleProto& a, CircleRuleProto& b) { a.Swap(&b); }
  inline void Swap(CircleRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircleRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CircleRuleProto>(arena);
  }
  void CopyFrom(const CircleRuleProto& from);
  void MergeFrom(const CircleRuleProto& from) { CircleRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CircleRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "CircleRuleProto"; }

 protected:
  explicit CircleRuleProto(::google::protobuf::Arena* arena);
  CircleRuleProto(::google::protobuf::Arena* arena, const CircleRuleProto& from);
  CircleRuleProto(::google::protobuf::Arena* arena, CircleRuleProto&& from) noexcept
      : CircleRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<16> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBorderFieldNumber = 3,
    kRadiusFieldNumber = 1,
    kColorFieldNumber = 2,
    kPriorityFieldNumber = 4,
  };
  // .LineDefProto border = 3;
  bool has_border() const;
  void clear_border() ;
  const ::LineDefProto& border() const;
  PROTOBUF_NODISCARD ::LineDefProto* release_border();
  ::LineDefProto* mutable_border();
  void set_allocated_border(::LineDefProto* value);
  void unsafe_arena_set_allocated_border(::LineDefProto* value);
  ::LineDefProto* unsafe_arena_release_border();

  private:
  const ::LineDefProto& _internal_border() const;
  ::LineDefProto* _internal_mutable_border();

  public:
  // double radius = 1;
  void clear_radius() ;
  double radius() const;
  void set_radius(double value);

  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);

  public:
  // uint32 color = 2;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // int32 priority = 4;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CircleRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CircleRuleProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::LineDefProto* border_;
    double radius_;
    ::uint32_t color_;
    ::int32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class AreaRuleProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:AreaRuleProto) */ {
 public:
  inline AreaRuleProto() : AreaRuleProto(nullptr) {}
  ~AreaRuleProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AreaRuleProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AreaRuleProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AreaRuleProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline AreaRuleProto(const AreaRuleProto& from) : AreaRuleProto(nullptr, from) {}
  inline AreaRuleProto(AreaRuleProto&& from) noexcept
      : AreaRuleProto(nullptr, std::move(from)) {}
  inline AreaRuleProto& operator=(const AreaRuleProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaRuleProto& operator=(AreaRuleProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AreaRuleProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaRuleProto* internal_default_instance() {
    return reinterpret_cast<const AreaRuleProto*>(
        &_AreaRuleProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AreaRuleProto& a, AreaRuleProto& b) { a.Swap(&b); }
  inline void Swap(AreaRuleProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaRuleProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaRuleProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<AreaRuleProto>(arena);
  }
  void CopyFrom(const AreaRuleProto& from);
  void MergeFrom(const AreaRuleProto& from) { AreaRuleProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AreaRuleProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "AreaRuleProto"; }

 protected:
  explicit AreaRuleProto(::google::protobuf::Arena* arena);
  AreaRuleProto(::google::protobuf::Arena* arena, const AreaRuleProto& from);
  AreaRuleProto(::google::protobuf::Arena* arena, AreaRuleProto&& from) noexcept
      : AreaRuleProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<14> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBorderFieldNumber = 2,
    kColorFieldNumber = 1,
    kPriorityFieldNumber = 3,
  };
  // .LineDefProto border = 2;
  bool has_border() const;
  void clear_border() ;
  const ::LineDefProto& border() const;
  PROTOBUF_NODISCARD ::LineDefProto* release_border();
  ::LineDefProto* mutable_border();
  void set_allocated_border(::LineDefProto* value);
  void unsafe_arena_set_allocated_border(::LineDefProto* value);
  ::LineDefProto* unsafe_arena_release_border();

  private:
  const ::LineDefProto& _internal_border() const;
  ::LineDefProto* _internal_mutable_border();

  public:
  // uint32 color = 1;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // int32 priority = 3;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:AreaRuleProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AreaRuleProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::LineDefProto* border_;
    ::uint32_t color_;
    ::int32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class DrawElementProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:DrawElementProto) */ {
 public:
  inline DrawElementProto() : DrawElementProto(nullptr) {}
  ~DrawElementProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DrawElementProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DrawElementProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DrawElementProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline DrawElementProto(const DrawElementProto& from) : DrawElementProto(nullptr, from) {}
  inline DrawElementProto(DrawElementProto&& from) noexcept
      : DrawElementProto(nullptr, std::move(from)) {}
  inline DrawElementProto& operator=(const DrawElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawElementProto& operator=(DrawElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DrawElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawElementProto* internal_default_instance() {
    return reinterpret_cast<const DrawElementProto*>(
        &_DrawElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(DrawElementProto& a, DrawElementProto& b) { a.Swap(&b); }
  inline void Swap(DrawElementProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawElementProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawElementProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DrawElementProto>(arena);
  }
  void CopyFrom(const DrawElementProto& from);
  void MergeFrom(const DrawElementProto& from) { DrawElementProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DrawElementProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "DrawElementProto"; }

 protected:
  explicit DrawElementProto(::google::protobuf::Arena* arena);
  DrawElementProto(::google::protobuf::Arena* arena, const DrawElementProto& from);
  DrawElementProto(::google::protobuf::Arena* arena, DrawElementProto&& from) noexcept
      : DrawElementProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<17> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinesFieldNumber = 2,
    kApplyIfFieldNumber = 9,
    kAreaFieldNumber = 3,
    kSymbolFieldNumber = 4,
    kCaptionFieldNumber = 5,
    kCircleFieldNumber = 6,
    kPathTextFieldNumber = 7,
    kShieldFieldNumber = 8,
    kScaleFieldNumber = 1,
  };
  // repeated .LineRuleProto lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;

  public:
  void clear_lines() ;
  ::LineRuleProto* mutable_lines(int index);
  ::google::protobuf::RepeatedPtrField<::LineRuleProto>* mutable_lines();

  private:
  const ::google::protobuf::RepeatedPtrField<::LineRuleProto>& _internal_lines() const;
  ::google::protobuf::RepeatedPtrField<::LineRuleProto>* _internal_mutable_lines();
  public:
  const ::LineRuleProto& lines(int index) const;
  ::LineRuleProto* add_lines();
  const ::google::protobuf::RepeatedPtrField<::LineRuleProto>& lines() const;
  // repeated string apply_if = 9;
  int apply_if_size() const;
  private:
  int _internal_apply_if_size() const;

  public:
  void clear_apply_if() ;
  const std::string& apply_if(int index) const;
  std::string* mutable_apply_if(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_apply_if(int index, Arg_&& value, Args_... args);
  std::string* add_apply_if();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_apply_if(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& apply_if() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_apply_if();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_apply_if() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_apply_if();

  public:
  // .AreaRuleProto area = 3;
  bool has_area() const;
  void clear_area() ;
  const ::AreaRuleProto& area() const;
  PROTOBUF_NODISCARD ::AreaRuleProto* release_area();
  ::AreaRuleProto* mutable_area();
  void set_allocated_area(::AreaRuleProto* value);
  void unsafe_arena_set_allocated_area(::AreaRuleProto* value);
  ::AreaRuleProto* unsafe_arena_release_area();

  private:
  const ::AreaRuleProto& _internal_area() const;
  ::AreaRuleProto* _internal_mutable_area();

  public:
  // .SymbolRuleProto symbol = 4;
  bool has_symbol() const;
  void clear_symbol() ;
  const ::SymbolRuleProto& symbol() const;
  PROTOBUF_NODISCARD ::SymbolRuleProto* release_symbol();
  ::SymbolRuleProto* mutable_symbol();
  void set_allocated_symbol(::SymbolRuleProto* value);
  void unsafe_arena_set_allocated_symbol(::SymbolRuleProto* value);
  ::SymbolRuleProto* unsafe_arena_release_symbol();

  private:
  const ::SymbolRuleProto& _internal_symbol() const;
  ::SymbolRuleProto* _internal_mutable_symbol();

  public:
  // .CaptionRuleProto caption = 5;
  bool has_caption() const;
  void clear_caption() ;
  const ::CaptionRuleProto& caption() const;
  PROTOBUF_NODISCARD ::CaptionRuleProto* release_caption();
  ::CaptionRuleProto* mutable_caption();
  void set_allocated_caption(::CaptionRuleProto* value);
  void unsafe_arena_set_allocated_caption(::CaptionRuleProto* value);
  ::CaptionRuleProto* unsafe_arena_release_caption();

  private:
  const ::CaptionRuleProto& _internal_caption() const;
  ::CaptionRuleProto* _internal_mutable_caption();

  public:
  // .CircleRuleProto circle = 6;
  bool has_circle() const;
  void clear_circle() ;
  const ::CircleRuleProto& circle() const;
  PROTOBUF_NODISCARD ::CircleRuleProto* release_circle();
  ::CircleRuleProto* mutable_circle();
  void set_allocated_circle(::CircleRuleProto* value);
  void unsafe_arena_set_allocated_circle(::CircleRuleProto* value);
  ::CircleRuleProto* unsafe_arena_release_circle();

  private:
  const ::CircleRuleProto& _internal_circle() const;
  ::CircleRuleProto* _internal_mutable_circle();

  public:
  // .PathTextRuleProto path_text = 7;
  bool has_path_text() const;
  void clear_path_text() ;
  const ::PathTextRuleProto& path_text() const;
  PROTOBUF_NODISCARD ::PathTextRuleProto* release_path_text();
  ::PathTextRuleProto* mutable_path_text();
  void set_allocated_path_text(::PathTextRuleProto* value);
  void unsafe_arena_set_allocated_path_text(::PathTextRuleProto* value);
  ::PathTextRuleProto* unsafe_arena_release_path_text();

  private:
  const ::PathTextRuleProto& _internal_path_text() const;
  ::PathTextRuleProto* _internal_mutable_path_text();

  public:
  // .ShieldRuleProto shield = 8;
  bool has_shield() const;
  void clear_shield() ;
  const ::ShieldRuleProto& shield() const;
  PROTOBUF_NODISCARD ::ShieldRuleProto* release_shield();
  ::ShieldRuleProto* mutable_shield();
  void set_allocated_shield(::ShieldRuleProto* value);
  void unsafe_arena_set_allocated_shield(::ShieldRuleProto* value);
  ::ShieldRuleProto* unsafe_arena_release_shield();

  private:
  const ::ShieldRuleProto& _internal_shield() const;
  ::ShieldRuleProto* _internal_mutable_shield();

  public:
  // int32 scale = 1;
  void clear_scale() ;
  ::int32_t scale() const;
  void set_scale(::int32_t value);

  private:
  ::int32_t _internal_scale() const;
  void _internal_set_scale(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DrawElementProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 7,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DrawElementProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::LineRuleProto > lines_;
    ::google::protobuf::RepeatedPtrField<std::string> apply_if_;
    ::AreaRuleProto* area_;
    ::SymbolRuleProto* symbol_;
    ::CaptionRuleProto* caption_;
    ::CircleRuleProto* circle_;
    ::PathTextRuleProto* path_text_;
    ::ShieldRuleProto* shield_;
    ::int32_t scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class ClassifElementProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ClassifElementProto) */ {
 public:
  inline ClassifElementProto() : ClassifElementProto(nullptr) {}
  ~ClassifElementProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClassifElementProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClassifElementProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClassifElementProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClassifElementProto(const ClassifElementProto& from) : ClassifElementProto(nullptr, from) {}
  inline ClassifElementProto(ClassifElementProto&& from) noexcept
      : ClassifElementProto(nullptr, std::move(from)) {}
  inline ClassifElementProto& operator=(const ClassifElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassifElementProto& operator=(ClassifElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClassifElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClassifElementProto* internal_default_instance() {
    return reinterpret_cast<const ClassifElementProto*>(
        &_ClassifElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ClassifElementProto& a, ClassifElementProto& b) { a.Swap(&b); }
  inline void Swap(ClassifElementProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClassifElementProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClassifElementProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ClassifElementProto>(arena);
  }
  void CopyFrom(const ClassifElementProto& from);
  void MergeFrom(const ClassifElementProto& from) { ClassifElementProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClassifElementProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ClassifElementProto"; }

 protected:
  explicit ClassifElementProto(::google::protobuf::Arena* arena);
  ClassifElementProto(::google::protobuf::Arena* arena, const ClassifElementProto& from);
  ClassifElementProto(::google::protobuf::Arena* arena, ClassifElementProto&& from) noexcept
      : ClassifElementProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<20> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElementFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .DrawElementProto element = 2;
  int element_size() const;
  private:
  int _internal_element_size() const;

  public:
  void clear_element() ;
  ::DrawElementProto* mutable_element(int index);
  ::google::protobuf::RepeatedPtrField<::DrawElementProto>* mutable_element();

  private:
  const ::google::protobuf::RepeatedPtrField<::DrawElementProto>& _internal_element() const;
  ::google::protobuf::RepeatedPtrField<::DrawElementProto>* _internal_mutable_element();
  public:
  const ::DrawElementProto& element(int index) const;
  ::DrawElementProto* add_element();
  const ::google::protobuf::RepeatedPtrField<::DrawElementProto>& element() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ClassifElementProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClassifElementProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::DrawElementProto > element_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};
// -------------------------------------------------------------------

class ContainerProto final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ContainerProto) */ {
 public:
  inline ContainerProto() : ContainerProto(nullptr) {}
  ~ContainerProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContainerProto* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContainerProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContainerProto(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContainerProto(const ContainerProto& from) : ContainerProto(nullptr, from) {}
  inline ContainerProto(ContainerProto&& from) noexcept
      : ContainerProto(nullptr, std::move(from)) {}
  inline ContainerProto& operator=(const ContainerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerProto& operator=(ContainerProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContainerProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainerProto* internal_default_instance() {
    return reinterpret_cast<const ContainerProto*>(
        &_ContainerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ContainerProto& a, ContainerProto& b) { a.Swap(&b); }
  inline void Swap(ContainerProto* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainerProto* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ContainerProto>(arena);
  }
  void CopyFrom(const ContainerProto& from);
  void MergeFrom(const ContainerProto& from) { ContainerProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContainerProto* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ContainerProto"; }

 protected:
  explicit ContainerProto(::google::protobuf::Arena* arena);
  ContainerProto(::google::protobuf::Arena* arena, const ContainerProto& from);
  ContainerProto(::google::protobuf::Arena* arena, ContainerProto&& from) noexcept
      : ContainerProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<15> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContFieldNumber = 1,
    kColorsFieldNumber = 2,
  };
  // repeated .ClassifElementProto cont = 1;
  int cont_size() const;
  private:
  int _internal_cont_size() const;

  public:
  void clear_cont() ;
  ::ClassifElementProto* mutable_cont(int index);
  ::google::protobuf::RepeatedPtrField<::ClassifElementProto>* mutable_cont();

  private:
  const ::google::protobuf::RepeatedPtrField<::ClassifElementProto>& _internal_cont() const;
  ::google::protobuf::RepeatedPtrField<::ClassifElementProto>* _internal_mutable_cont();
  public:
  const ::ClassifElementProto& cont(int index) const;
  ::ClassifElementProto* add_cont();
  const ::google::protobuf::RepeatedPtrField<::ClassifElementProto>& cont() const;
  // .ColorsElementProto colors = 2;
  bool has_colors() const;
  void clear_colors() ;
  const ::ColorsElementProto& colors() const;
  PROTOBUF_NODISCARD ::ColorsElementProto* release_colors();
  ::ColorsElementProto* mutable_colors();
  void set_allocated_colors(::ColorsElementProto* value);
  void unsafe_arena_set_allocated_colors(::ColorsElementProto* value);
  ::ColorsElementProto* unsafe_arena_release_colors();

  private:
  const ::ColorsElementProto& _internal_colors() const;
  ::ColorsElementProto* _internal_mutable_colors();

  public:
  // @@protoc_insertion_point(class_scope:ContainerProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContainerProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ClassifElementProto > cont_;
    ::ColorsElementProto* colors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_drules_5fstruct_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DashDotProto

// repeated double dd = 1;
inline int DashDotProto::_internal_dd_size() const {
  return _internal_dd().size();
}
inline int DashDotProto::dd_size() const {
  return _internal_dd_size();
}
inline void DashDotProto::clear_dd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dd_.Clear();
}
inline double DashDotProto::dd(int index) const {
  // @@protoc_insertion_point(field_get:DashDotProto.dd)
  return _internal_dd().Get(index);
}
inline void DashDotProto::set_dd(int index, double value) {
  _internal_mutable_dd()->Set(index, value);
  // @@protoc_insertion_point(field_set:DashDotProto.dd)
}
inline void DashDotProto::add_dd(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_dd()->Add(value);
  // @@protoc_insertion_point(field_add:DashDotProto.dd)
}
inline const ::google::protobuf::RepeatedField<double>& DashDotProto::dd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DashDotProto.dd)
  return _internal_dd();
}
inline ::google::protobuf::RepeatedField<double>* DashDotProto::mutable_dd()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DashDotProto.dd)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dd();
}
inline const ::google::protobuf::RepeatedField<double>&
DashDotProto::_internal_dd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dd_;
}
inline ::google::protobuf::RepeatedField<double>* DashDotProto::_internal_mutable_dd() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dd_;
}

// double offset = 2;
inline void DashDotProto::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
}
inline double DashDotProto::offset() const {
  // @@protoc_insertion_point(field_get:DashDotProto.offset)
  return _internal_offset();
}
inline void DashDotProto::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:DashDotProto.offset)
}
inline double DashDotProto::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void DashDotProto::_internal_set_offset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// PathSymProto

// string name = 1;
inline void PathSymProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PathSymProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PathSymProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PathSymProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:PathSymProto.name)
}
inline std::string* PathSymProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PathSymProto.name)
  return _s;
}
inline const std::string& PathSymProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void PathSymProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PathSymProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PathSymProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PathSymProto.name)
  return _impl_.name_.Release();
}
inline void PathSymProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:PathSymProto.name)
}

// double step = 2;
inline void PathSymProto::clear_step() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = 0;
}
inline double PathSymProto::step() const {
  // @@protoc_insertion_point(field_get:PathSymProto.step)
  return _internal_step();
}
inline void PathSymProto::set_step(double value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:PathSymProto.step)
}
inline double PathSymProto::_internal_step() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.step_;
}
inline void PathSymProto::_internal_set_step(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.step_ = value;
}

// double offset = 3;
inline void PathSymProto::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
}
inline double PathSymProto::offset() const {
  // @@protoc_insertion_point(field_get:PathSymProto.offset)
  return _internal_offset();
}
inline void PathSymProto::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:PathSymProto.offset)
}
inline double PathSymProto::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void PathSymProto::_internal_set_offset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// LineRuleProto

// double width = 1;
inline void LineRuleProto::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
}
inline double LineRuleProto::width() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.width)
  return _internal_width();
}
inline void LineRuleProto::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:LineRuleProto.width)
}
inline double LineRuleProto::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void LineRuleProto::_internal_set_width(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 color = 2;
inline void LineRuleProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t LineRuleProto::color() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.color)
  return _internal_color();
}
inline void LineRuleProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:LineRuleProto.color)
}
inline ::uint32_t LineRuleProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void LineRuleProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .DashDotProto dashdot = 3;
inline bool LineRuleProto::has_dashdot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dashdot_ != nullptr);
  return value;
}
inline void LineRuleProto::clear_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dashdot_ != nullptr) _impl_.dashdot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DashDotProto& LineRuleProto::_internal_dashdot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DashDotProto* p = _impl_.dashdot_;
  return p != nullptr ? *p : reinterpret_cast<const ::DashDotProto&>(::_DashDotProto_default_instance_);
}
inline const ::DashDotProto& LineRuleProto::dashdot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LineRuleProto.dashdot)
  return _internal_dashdot();
}
inline void LineRuleProto::unsafe_arena_set_allocated_dashdot(::DashDotProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dashdot_);
  }
  _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LineRuleProto.dashdot)
}
inline ::DashDotProto* LineRuleProto::release_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DashDotProto* released = _impl_.dashdot_;
  _impl_.dashdot_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DashDotProto* LineRuleProto::unsafe_arena_release_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LineRuleProto.dashdot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DashDotProto* temp = _impl_.dashdot_;
  _impl_.dashdot_ = nullptr;
  return temp;
}
inline ::DashDotProto* LineRuleProto::_internal_mutable_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dashdot_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::DashDotProto>(GetArena());
    _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(p);
  }
  return _impl_.dashdot_;
}
inline ::DashDotProto* LineRuleProto::mutable_dashdot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DashDotProto* _msg = _internal_mutable_dashdot();
  // @@protoc_insertion_point(field_mutable:LineRuleProto.dashdot)
  return _msg;
}
inline void LineRuleProto::set_allocated_dashdot(::DashDotProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dashdot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:LineRuleProto.dashdot)
}

// int32 priority = 4;
inline void LineRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t LineRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.priority)
  return _internal_priority();
}
inline void LineRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:LineRuleProto.priority)
}
inline ::int32_t LineRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void LineRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// .PathSymProto pathsym = 5;
inline bool LineRuleProto::has_pathsym() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathsym_ != nullptr);
  return value;
}
inline void LineRuleProto::clear_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pathsym_ != nullptr) _impl_.pathsym_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PathSymProto& LineRuleProto::_internal_pathsym() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::PathSymProto* p = _impl_.pathsym_;
  return p != nullptr ? *p : reinterpret_cast<const ::PathSymProto&>(::_PathSymProto_default_instance_);
}
inline const ::PathSymProto& LineRuleProto::pathsym() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LineRuleProto.pathsym)
  return _internal_pathsym();
}
inline void LineRuleProto::unsafe_arena_set_allocated_pathsym(::PathSymProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pathsym_);
  }
  _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LineRuleProto.pathsym)
}
inline ::PathSymProto* LineRuleProto::release_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PathSymProto* released = _impl_.pathsym_;
  _impl_.pathsym_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::PathSymProto* LineRuleProto::unsafe_arena_release_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LineRuleProto.pathsym)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PathSymProto* temp = _impl_.pathsym_;
  _impl_.pathsym_ = nullptr;
  return temp;
}
inline ::PathSymProto* LineRuleProto::_internal_mutable_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pathsym_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::PathSymProto>(GetArena());
    _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(p);
  }
  return _impl_.pathsym_;
}
inline ::PathSymProto* LineRuleProto::mutable_pathsym() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PathSymProto* _msg = _internal_mutable_pathsym();
  // @@protoc_insertion_point(field_mutable:LineRuleProto.pathsym)
  return _msg;
}
inline void LineRuleProto::set_allocated_pathsym(::PathSymProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pathsym_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:LineRuleProto.pathsym)
}

// .LineJoin join = 6;
inline void LineRuleProto::clear_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_ = 0;
}
inline ::LineJoin LineRuleProto::join() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.join)
  return _internal_join();
}
inline void LineRuleProto::set_join(::LineJoin value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:LineRuleProto.join)
}
inline ::LineJoin LineRuleProto::_internal_join() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LineJoin>(_impl_.join_);
}
inline void LineRuleProto::_internal_set_join(::LineJoin value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_ = value;
}

// .LineCap cap = 7;
inline void LineRuleProto::clear_cap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_ = 0;
}
inline ::LineCap LineRuleProto::cap() const {
  // @@protoc_insertion_point(field_get:LineRuleProto.cap)
  return _internal_cap();
}
inline void LineRuleProto::set_cap(::LineCap value) {
  _internal_set_cap(value);
  // @@protoc_insertion_point(field_set:LineRuleProto.cap)
}
inline ::LineCap LineRuleProto::_internal_cap() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LineCap>(_impl_.cap_);
}
inline void LineRuleProto::_internal_set_cap(::LineCap value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_ = value;
}

// -------------------------------------------------------------------

// LineDefProto

// double width = 1;
inline void LineDefProto::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
}
inline double LineDefProto::width() const {
  // @@protoc_insertion_point(field_get:LineDefProto.width)
  return _internal_width();
}
inline void LineDefProto::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:LineDefProto.width)
}
inline double LineDefProto::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void LineDefProto::_internal_set_width(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 color = 2;
inline void LineDefProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t LineDefProto::color() const {
  // @@protoc_insertion_point(field_get:LineDefProto.color)
  return _internal_color();
}
inline void LineDefProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:LineDefProto.color)
}
inline ::uint32_t LineDefProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void LineDefProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .DashDotProto dashdot = 3;
inline bool LineDefProto::has_dashdot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dashdot_ != nullptr);
  return value;
}
inline void LineDefProto::clear_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dashdot_ != nullptr) _impl_.dashdot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::DashDotProto& LineDefProto::_internal_dashdot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::DashDotProto* p = _impl_.dashdot_;
  return p != nullptr ? *p : reinterpret_cast<const ::DashDotProto&>(::_DashDotProto_default_instance_);
}
inline const ::DashDotProto& LineDefProto::dashdot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LineDefProto.dashdot)
  return _internal_dashdot();
}
inline void LineDefProto::unsafe_arena_set_allocated_dashdot(::DashDotProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dashdot_);
  }
  _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LineDefProto.dashdot)
}
inline ::DashDotProto* LineDefProto::release_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DashDotProto* released = _impl_.dashdot_;
  _impl_.dashdot_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::DashDotProto* LineDefProto::unsafe_arena_release_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LineDefProto.dashdot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DashDotProto* temp = _impl_.dashdot_;
  _impl_.dashdot_ = nullptr;
  return temp;
}
inline ::DashDotProto* LineDefProto::_internal_mutable_dashdot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dashdot_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::DashDotProto>(GetArena());
    _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(p);
  }
  return _impl_.dashdot_;
}
inline ::DashDotProto* LineDefProto::mutable_dashdot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DashDotProto* _msg = _internal_mutable_dashdot();
  // @@protoc_insertion_point(field_mutable:LineDefProto.dashdot)
  return _msg;
}
inline void LineDefProto::set_allocated_dashdot(::DashDotProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dashdot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dashdot_ = reinterpret_cast<::DashDotProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:LineDefProto.dashdot)
}

// .PathSymProto pathsym = 4;
inline bool LineDefProto::has_pathsym() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathsym_ != nullptr);
  return value;
}
inline void LineDefProto::clear_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pathsym_ != nullptr) _impl_.pathsym_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::PathSymProto& LineDefProto::_internal_pathsym() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::PathSymProto* p = _impl_.pathsym_;
  return p != nullptr ? *p : reinterpret_cast<const ::PathSymProto&>(::_PathSymProto_default_instance_);
}
inline const ::PathSymProto& LineDefProto::pathsym() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:LineDefProto.pathsym)
  return _internal_pathsym();
}
inline void LineDefProto::unsafe_arena_set_allocated_pathsym(::PathSymProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pathsym_);
  }
  _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LineDefProto.pathsym)
}
inline ::PathSymProto* LineDefProto::release_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PathSymProto* released = _impl_.pathsym_;
  _impl_.pathsym_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::PathSymProto* LineDefProto::unsafe_arena_release_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:LineDefProto.pathsym)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PathSymProto* temp = _impl_.pathsym_;
  _impl_.pathsym_ = nullptr;
  return temp;
}
inline ::PathSymProto* LineDefProto::_internal_mutable_pathsym() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pathsym_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::PathSymProto>(GetArena());
    _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(p);
  }
  return _impl_.pathsym_;
}
inline ::PathSymProto* LineDefProto::mutable_pathsym() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::PathSymProto* _msg = _internal_mutable_pathsym();
  // @@protoc_insertion_point(field_mutable:LineDefProto.pathsym)
  return _msg;
}
inline void LineDefProto::set_allocated_pathsym(::PathSymProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pathsym_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pathsym_ = reinterpret_cast<::PathSymProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:LineDefProto.pathsym)
}

// .LineJoin join = 6;
inline void LineDefProto::clear_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_ = 0;
}
inline ::LineJoin LineDefProto::join() const {
  // @@protoc_insertion_point(field_get:LineDefProto.join)
  return _internal_join();
}
inline void LineDefProto::set_join(::LineJoin value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:LineDefProto.join)
}
inline ::LineJoin LineDefProto::_internal_join() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LineJoin>(_impl_.join_);
}
inline void LineDefProto::_internal_set_join(::LineJoin value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.join_ = value;
}

// .LineCap cap = 7;
inline void LineDefProto::clear_cap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_ = 0;
}
inline ::LineCap LineDefProto::cap() const {
  // @@protoc_insertion_point(field_get:LineDefProto.cap)
  return _internal_cap();
}
inline void LineDefProto::set_cap(::LineCap value) {
  _internal_set_cap(value);
  // @@protoc_insertion_point(field_set:LineDefProto.cap)
}
inline ::LineCap LineDefProto::_internal_cap() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::LineCap>(_impl_.cap_);
}
inline void LineDefProto::_internal_set_cap(::LineCap value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cap_ = value;
}

// -------------------------------------------------------------------

// AreaRuleProto

// uint32 color = 1;
inline void AreaRuleProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t AreaRuleProto::color() const {
  // @@protoc_insertion_point(field_get:AreaRuleProto.color)
  return _internal_color();
}
inline void AreaRuleProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:AreaRuleProto.color)
}
inline ::uint32_t AreaRuleProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void AreaRuleProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .LineDefProto border = 2;
inline bool AreaRuleProto::has_border() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.border_ != nullptr);
  return value;
}
inline void AreaRuleProto::clear_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.border_ != nullptr) _impl_.border_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::LineDefProto& AreaRuleProto::_internal_border() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::LineDefProto* p = _impl_.border_;
  return p != nullptr ? *p : reinterpret_cast<const ::LineDefProto&>(::_LineDefProto_default_instance_);
}
inline const ::LineDefProto& AreaRuleProto::border() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AreaRuleProto.border)
  return _internal_border();
}
inline void AreaRuleProto::unsafe_arena_set_allocated_border(::LineDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.border_);
  }
  _impl_.border_ = reinterpret_cast<::LineDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AreaRuleProto.border)
}
inline ::LineDefProto* AreaRuleProto::release_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LineDefProto* released = _impl_.border_;
  _impl_.border_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::LineDefProto* AreaRuleProto::unsafe_arena_release_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:AreaRuleProto.border)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LineDefProto* temp = _impl_.border_;
  _impl_.border_ = nullptr;
  return temp;
}
inline ::LineDefProto* AreaRuleProto::_internal_mutable_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.border_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::LineDefProto>(GetArena());
    _impl_.border_ = reinterpret_cast<::LineDefProto*>(p);
  }
  return _impl_.border_;
}
inline ::LineDefProto* AreaRuleProto::mutable_border() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::LineDefProto* _msg = _internal_mutable_border();
  // @@protoc_insertion_point(field_mutable:AreaRuleProto.border)
  return _msg;
}
inline void AreaRuleProto::set_allocated_border(::LineDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.border_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.border_ = reinterpret_cast<::LineDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:AreaRuleProto.border)
}

// int32 priority = 3;
inline void AreaRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t AreaRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:AreaRuleProto.priority)
  return _internal_priority();
}
inline void AreaRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:AreaRuleProto.priority)
}
inline ::int32_t AreaRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void AreaRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// -------------------------------------------------------------------

// SymbolRuleProto

// string name = 1;
inline void SymbolRuleProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SymbolRuleProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymbolRuleProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SymbolRuleProto.name)
}
inline std::string* SymbolRuleProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SymbolRuleProto.name)
  return _s;
}
inline const std::string& SymbolRuleProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void SymbolRuleProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SymbolRuleProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SymbolRuleProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:SymbolRuleProto.name)
  return _impl_.name_.Release();
}
inline void SymbolRuleProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:SymbolRuleProto.name)
}

// int32 apply_for_type = 2;
inline void SymbolRuleProto::clear_apply_for_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_for_type_ = 0;
}
inline ::int32_t SymbolRuleProto::apply_for_type() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.apply_for_type)
  return _internal_apply_for_type();
}
inline void SymbolRuleProto::set_apply_for_type(::int32_t value) {
  _internal_set_apply_for_type(value);
  // @@protoc_insertion_point(field_set:SymbolRuleProto.apply_for_type)
}
inline ::int32_t SymbolRuleProto::_internal_apply_for_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apply_for_type_;
}
inline void SymbolRuleProto::_internal_set_apply_for_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_for_type_ = value;
}

// int32 priority = 3;
inline void SymbolRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t SymbolRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.priority)
  return _internal_priority();
}
inline void SymbolRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:SymbolRuleProto.priority)
}
inline ::int32_t SymbolRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void SymbolRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// int32 min_distance = 4;
inline void SymbolRuleProto::clear_min_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_distance_ = 0;
}
inline ::int32_t SymbolRuleProto::min_distance() const {
  // @@protoc_insertion_point(field_get:SymbolRuleProto.min_distance)
  return _internal_min_distance();
}
inline void SymbolRuleProto::set_min_distance(::int32_t value) {
  _internal_set_min_distance(value);
  // @@protoc_insertion_point(field_set:SymbolRuleProto.min_distance)
}
inline ::int32_t SymbolRuleProto::_internal_min_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_distance_;
}
inline void SymbolRuleProto::_internal_set_min_distance(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_distance_ = value;
}

// -------------------------------------------------------------------

// CaptionDefProto

// int32 height = 1;
inline void CaptionDefProto::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
}
inline ::int32_t CaptionDefProto::height() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.height)
  return _internal_height();
}
inline void CaptionDefProto::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.height)
}
inline ::int32_t CaptionDefProto::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void CaptionDefProto::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// uint32 color = 2;
inline void CaptionDefProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t CaptionDefProto::color() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.color)
  return _internal_color();
}
inline void CaptionDefProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.color)
}
inline ::uint32_t CaptionDefProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void CaptionDefProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// uint32 stroke_color = 3;
inline void CaptionDefProto::clear_stroke_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stroke_color_ = 0u;
}
inline ::uint32_t CaptionDefProto::stroke_color() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.stroke_color)
  return _internal_stroke_color();
}
inline void CaptionDefProto::set_stroke_color(::uint32_t value) {
  _internal_set_stroke_color(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.stroke_color)
}
inline ::uint32_t CaptionDefProto::_internal_stroke_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stroke_color_;
}
inline void CaptionDefProto::_internal_set_stroke_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stroke_color_ = value;
}

// int32 offset_x = 4;
inline void CaptionDefProto::clear_offset_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_x_ = 0;
}
inline ::int32_t CaptionDefProto::offset_x() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.offset_x)
  return _internal_offset_x();
}
inline void CaptionDefProto::set_offset_x(::int32_t value) {
  _internal_set_offset_x(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.offset_x)
}
inline ::int32_t CaptionDefProto::_internal_offset_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_x_;
}
inline void CaptionDefProto::_internal_set_offset_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_x_ = value;
}

// int32 offset_y = 5;
inline void CaptionDefProto::clear_offset_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_y_ = 0;
}
inline ::int32_t CaptionDefProto::offset_y() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.offset_y)
  return _internal_offset_y();
}
inline void CaptionDefProto::set_offset_y(::int32_t value) {
  _internal_set_offset_y(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.offset_y)
}
inline ::int32_t CaptionDefProto::_internal_offset_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_y_;
}
inline void CaptionDefProto::_internal_set_offset_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_y_ = value;
}

// string text = 6;
inline void CaptionDefProto::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& CaptionDefProto::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CaptionDefProto.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CaptionDefProto::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CaptionDefProto.text)
}
inline std::string* CaptionDefProto::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:CaptionDefProto.text)
  return _s;
}
inline const std::string& CaptionDefProto::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void CaptionDefProto::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* CaptionDefProto::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* CaptionDefProto::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:CaptionDefProto.text)
  return _impl_.text_.Release();
}
inline void CaptionDefProto::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:CaptionDefProto.text)
}

// bool is_optional = 7;
inline void CaptionDefProto::clear_is_optional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_optional_ = false;
}
inline bool CaptionDefProto::is_optional() const {
  // @@protoc_insertion_point(field_get:CaptionDefProto.is_optional)
  return _internal_is_optional();
}
inline void CaptionDefProto::set_is_optional(bool value) {
  _internal_set_is_optional(value);
  // @@protoc_insertion_point(field_set:CaptionDefProto.is_optional)
}
inline bool CaptionDefProto::_internal_is_optional() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_optional_;
}
inline void CaptionDefProto::_internal_set_is_optional(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_optional_ = value;
}

// -------------------------------------------------------------------

// CaptionRuleProto

// .CaptionDefProto primary = 1;
inline bool CaptionRuleProto::has_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primary_ != nullptr);
  return value;
}
inline void CaptionRuleProto::clear_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_ != nullptr) _impl_.primary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CaptionDefProto& CaptionRuleProto::_internal_primary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CaptionDefProto* p = _impl_.primary_;
  return p != nullptr ? *p : reinterpret_cast<const ::CaptionDefProto&>(::_CaptionDefProto_default_instance_);
}
inline const ::CaptionDefProto& CaptionRuleProto::primary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.primary)
  return _internal_primary();
}
inline void CaptionRuleProto::unsafe_arena_set_allocated_primary(::CaptionDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_);
  }
  _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CaptionRuleProto.primary)
}
inline ::CaptionDefProto* CaptionRuleProto::release_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CaptionDefProto* released = _impl_.primary_;
  _impl_.primary_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CaptionDefProto* CaptionRuleProto::unsafe_arena_release_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:CaptionRuleProto.primary)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CaptionDefProto* temp = _impl_.primary_;
  _impl_.primary_ = nullptr;
  return temp;
}
inline ::CaptionDefProto* CaptionRuleProto::_internal_mutable_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CaptionDefProto>(GetArena());
    _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(p);
  }
  return _impl_.primary_;
}
inline ::CaptionDefProto* CaptionRuleProto::mutable_primary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::CaptionDefProto* _msg = _internal_mutable_primary();
  // @@protoc_insertion_point(field_mutable:CaptionRuleProto.primary)
  return _msg;
}
inline void CaptionRuleProto::set_allocated_primary(::CaptionDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.primary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:CaptionRuleProto.primary)
}

// .CaptionDefProto secondary = 2;
inline bool CaptionRuleProto::has_secondary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondary_ != nullptr);
  return value;
}
inline void CaptionRuleProto::clear_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_ != nullptr) _impl_.secondary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CaptionDefProto& CaptionRuleProto::_internal_secondary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CaptionDefProto* p = _impl_.secondary_;
  return p != nullptr ? *p : reinterpret_cast<const ::CaptionDefProto&>(::_CaptionDefProto_default_instance_);
}
inline const ::CaptionDefProto& CaptionRuleProto::secondary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.secondary)
  return _internal_secondary();
}
inline void CaptionRuleProto::unsafe_arena_set_allocated_secondary(::CaptionDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_);
  }
  _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CaptionRuleProto.secondary)
}
inline ::CaptionDefProto* CaptionRuleProto::release_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CaptionDefProto* released = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CaptionDefProto* CaptionRuleProto::unsafe_arena_release_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:CaptionRuleProto.secondary)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CaptionDefProto* temp = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
  return temp;
}
inline ::CaptionDefProto* CaptionRuleProto::_internal_mutable_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CaptionDefProto>(GetArena());
    _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(p);
  }
  return _impl_.secondary_;
}
inline ::CaptionDefProto* CaptionRuleProto::mutable_secondary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::CaptionDefProto* _msg = _internal_mutable_secondary();
  // @@protoc_insertion_point(field_mutable:CaptionRuleProto.secondary)
  return _msg;
}
inline void CaptionRuleProto::set_allocated_secondary(::CaptionDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.secondary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:CaptionRuleProto.secondary)
}

// int32 priority = 3;
inline void CaptionRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t CaptionRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:CaptionRuleProto.priority)
  return _internal_priority();
}
inline void CaptionRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:CaptionRuleProto.priority)
}
inline ::int32_t CaptionRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void CaptionRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// -------------------------------------------------------------------

// CircleRuleProto

// double radius = 1;
inline void CircleRuleProto::clear_radius() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radius_ = 0;
}
inline double CircleRuleProto::radius() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.radius)
  return _internal_radius();
}
inline void CircleRuleProto::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:CircleRuleProto.radius)
}
inline double CircleRuleProto::_internal_radius() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radius_;
}
inline void CircleRuleProto::_internal_set_radius(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radius_ = value;
}

// uint32 color = 2;
inline void CircleRuleProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t CircleRuleProto::color() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.color)
  return _internal_color();
}
inline void CircleRuleProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:CircleRuleProto.color)
}
inline ::uint32_t CircleRuleProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void CircleRuleProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// .LineDefProto border = 3;
inline bool CircleRuleProto::has_border() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.border_ != nullptr);
  return value;
}
inline void CircleRuleProto::clear_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.border_ != nullptr) _impl_.border_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::LineDefProto& CircleRuleProto::_internal_border() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::LineDefProto* p = _impl_.border_;
  return p != nullptr ? *p : reinterpret_cast<const ::LineDefProto&>(::_LineDefProto_default_instance_);
}
inline const ::LineDefProto& CircleRuleProto::border() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CircleRuleProto.border)
  return _internal_border();
}
inline void CircleRuleProto::unsafe_arena_set_allocated_border(::LineDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.border_);
  }
  _impl_.border_ = reinterpret_cast<::LineDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CircleRuleProto.border)
}
inline ::LineDefProto* CircleRuleProto::release_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LineDefProto* released = _impl_.border_;
  _impl_.border_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::LineDefProto* CircleRuleProto::unsafe_arena_release_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:CircleRuleProto.border)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::LineDefProto* temp = _impl_.border_;
  _impl_.border_ = nullptr;
  return temp;
}
inline ::LineDefProto* CircleRuleProto::_internal_mutable_border() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.border_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::LineDefProto>(GetArena());
    _impl_.border_ = reinterpret_cast<::LineDefProto*>(p);
  }
  return _impl_.border_;
}
inline ::LineDefProto* CircleRuleProto::mutable_border() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::LineDefProto* _msg = _internal_mutable_border();
  // @@protoc_insertion_point(field_mutable:CircleRuleProto.border)
  return _msg;
}
inline void CircleRuleProto::set_allocated_border(::LineDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.border_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.border_ = reinterpret_cast<::LineDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:CircleRuleProto.border)
}

// int32 priority = 4;
inline void CircleRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t CircleRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:CircleRuleProto.priority)
  return _internal_priority();
}
inline void CircleRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:CircleRuleProto.priority)
}
inline ::int32_t CircleRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void CircleRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// -------------------------------------------------------------------

// PathTextRuleProto

// .CaptionDefProto primary = 1;
inline bool PathTextRuleProto::has_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.primary_ != nullptr);
  return value;
}
inline void PathTextRuleProto::clear_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_ != nullptr) _impl_.primary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CaptionDefProto& PathTextRuleProto::_internal_primary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CaptionDefProto* p = _impl_.primary_;
  return p != nullptr ? *p : reinterpret_cast<const ::CaptionDefProto&>(::_CaptionDefProto_default_instance_);
}
inline const ::CaptionDefProto& PathTextRuleProto::primary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.primary)
  return _internal_primary();
}
inline void PathTextRuleProto::unsafe_arena_set_allocated_primary(::CaptionDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.primary_);
  }
  _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathTextRuleProto.primary)
}
inline ::CaptionDefProto* PathTextRuleProto::release_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CaptionDefProto* released = _impl_.primary_;
  _impl_.primary_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CaptionDefProto* PathTextRuleProto::unsafe_arena_release_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PathTextRuleProto.primary)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CaptionDefProto* temp = _impl_.primary_;
  _impl_.primary_ = nullptr;
  return temp;
}
inline ::CaptionDefProto* PathTextRuleProto::_internal_mutable_primary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.primary_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CaptionDefProto>(GetArena());
    _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(p);
  }
  return _impl_.primary_;
}
inline ::CaptionDefProto* PathTextRuleProto::mutable_primary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::CaptionDefProto* _msg = _internal_mutable_primary();
  // @@protoc_insertion_point(field_mutable:PathTextRuleProto.primary)
  return _msg;
}
inline void PathTextRuleProto::set_allocated_primary(::CaptionDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.primary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.primary_ = reinterpret_cast<::CaptionDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:PathTextRuleProto.primary)
}

// .CaptionDefProto secondary = 2;
inline bool PathTextRuleProto::has_secondary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.secondary_ != nullptr);
  return value;
}
inline void PathTextRuleProto::clear_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_ != nullptr) _impl_.secondary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CaptionDefProto& PathTextRuleProto::_internal_secondary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CaptionDefProto* p = _impl_.secondary_;
  return p != nullptr ? *p : reinterpret_cast<const ::CaptionDefProto&>(::_CaptionDefProto_default_instance_);
}
inline const ::CaptionDefProto& PathTextRuleProto::secondary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.secondary)
  return _internal_secondary();
}
inline void PathTextRuleProto::unsafe_arena_set_allocated_secondary(::CaptionDefProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.secondary_);
  }
  _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathTextRuleProto.secondary)
}
inline ::CaptionDefProto* PathTextRuleProto::release_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CaptionDefProto* released = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CaptionDefProto* PathTextRuleProto::unsafe_arena_release_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:PathTextRuleProto.secondary)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CaptionDefProto* temp = _impl_.secondary_;
  _impl_.secondary_ = nullptr;
  return temp;
}
inline ::CaptionDefProto* PathTextRuleProto::_internal_mutable_secondary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.secondary_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CaptionDefProto>(GetArena());
    _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(p);
  }
  return _impl_.secondary_;
}
inline ::CaptionDefProto* PathTextRuleProto::mutable_secondary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::CaptionDefProto* _msg = _internal_mutable_secondary();
  // @@protoc_insertion_point(field_mutable:PathTextRuleProto.secondary)
  return _msg;
}
inline void PathTextRuleProto::set_allocated_secondary(::CaptionDefProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.secondary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.secondary_ = reinterpret_cast<::CaptionDefProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:PathTextRuleProto.secondary)
}

// int32 priority = 3;
inline void PathTextRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t PathTextRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:PathTextRuleProto.priority)
  return _internal_priority();
}
inline void PathTextRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:PathTextRuleProto.priority)
}
inline ::int32_t PathTextRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void PathTextRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// -------------------------------------------------------------------

// ShieldRuleProto

// int32 height = 1;
inline void ShieldRuleProto::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
}
inline ::int32_t ShieldRuleProto::height() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.height)
  return _internal_height();
}
inline void ShieldRuleProto::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.height)
}
inline ::int32_t ShieldRuleProto::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void ShieldRuleProto::_internal_set_height(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// uint32 color = 2;
inline void ShieldRuleProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t ShieldRuleProto::color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.color)
  return _internal_color();
}
inline void ShieldRuleProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.color)
}
inline ::uint32_t ShieldRuleProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void ShieldRuleProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// uint32 stroke_color = 3;
inline void ShieldRuleProto::clear_stroke_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stroke_color_ = 0u;
}
inline ::uint32_t ShieldRuleProto::stroke_color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.stroke_color)
  return _internal_stroke_color();
}
inline void ShieldRuleProto::set_stroke_color(::uint32_t value) {
  _internal_set_stroke_color(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.stroke_color)
}
inline ::uint32_t ShieldRuleProto::_internal_stroke_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stroke_color_;
}
inline void ShieldRuleProto::_internal_set_stroke_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stroke_color_ = value;
}

// int32 priority = 4;
inline void ShieldRuleProto::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::int32_t ShieldRuleProto::priority() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.priority)
  return _internal_priority();
}
inline void ShieldRuleProto::set_priority(::int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.priority)
}
inline ::int32_t ShieldRuleProto::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_;
}
inline void ShieldRuleProto::_internal_set_priority(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// int32 min_distance = 5;
inline void ShieldRuleProto::clear_min_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_distance_ = 0;
}
inline ::int32_t ShieldRuleProto::min_distance() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.min_distance)
  return _internal_min_distance();
}
inline void ShieldRuleProto::set_min_distance(::int32_t value) {
  _internal_set_min_distance(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.min_distance)
}
inline ::int32_t ShieldRuleProto::_internal_min_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_distance_;
}
inline void ShieldRuleProto::_internal_set_min_distance(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_distance_ = value;
}

// uint32 text_color = 6;
inline void ShieldRuleProto::clear_text_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_color_ = 0u;
}
inline ::uint32_t ShieldRuleProto::text_color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.text_color)
  return _internal_text_color();
}
inline void ShieldRuleProto::set_text_color(::uint32_t value) {
  _internal_set_text_color(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.text_color)
}
inline ::uint32_t ShieldRuleProto::_internal_text_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_color_;
}
inline void ShieldRuleProto::_internal_set_text_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_color_ = value;
}

// uint32 text_stroke_color = 7;
inline void ShieldRuleProto::clear_text_stroke_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_stroke_color_ = 0u;
}
inline ::uint32_t ShieldRuleProto::text_stroke_color() const {
  // @@protoc_insertion_point(field_get:ShieldRuleProto.text_stroke_color)
  return _internal_text_stroke_color();
}
inline void ShieldRuleProto::set_text_stroke_color(::uint32_t value) {
  _internal_set_text_stroke_color(value);
  // @@protoc_insertion_point(field_set:ShieldRuleProto.text_stroke_color)
}
inline ::uint32_t ShieldRuleProto::_internal_text_stroke_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_stroke_color_;
}
inline void ShieldRuleProto::_internal_set_text_stroke_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_stroke_color_ = value;
}

// -------------------------------------------------------------------

// DrawElementProto

// int32 scale = 1;
inline void DrawElementProto::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = 0;
}
inline ::int32_t DrawElementProto::scale() const {
  // @@protoc_insertion_point(field_get:DrawElementProto.scale)
  return _internal_scale();
}
inline void DrawElementProto::set_scale(::int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:DrawElementProto.scale)
}
inline ::int32_t DrawElementProto::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scale_;
}
inline void DrawElementProto::_internal_set_scale(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = value;
}

// repeated .LineRuleProto lines = 2;
inline int DrawElementProto::_internal_lines_size() const {
  return _internal_lines().size();
}
inline int DrawElementProto::lines_size() const {
  return _internal_lines_size();
}
inline void DrawElementProto::clear_lines() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lines_.Clear();
}
inline ::LineRuleProto* DrawElementProto::mutable_lines(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DrawElementProto.lines)
  return _internal_mutable_lines()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::LineRuleProto>* DrawElementProto::mutable_lines()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DrawElementProto.lines)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lines();
}
inline const ::LineRuleProto& DrawElementProto::lines(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.lines)
  return _internal_lines().Get(index);
}
inline ::LineRuleProto* DrawElementProto::add_lines() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::LineRuleProto* _add = _internal_mutable_lines()->Add();
  // @@protoc_insertion_point(field_add:DrawElementProto.lines)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::LineRuleProto>& DrawElementProto::lines() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DrawElementProto.lines)
  return _internal_lines();
}
inline const ::google::protobuf::RepeatedPtrField<::LineRuleProto>&
DrawElementProto::_internal_lines() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lines_;
}
inline ::google::protobuf::RepeatedPtrField<::LineRuleProto>*
DrawElementProto::_internal_mutable_lines() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lines_;
}

// .AreaRuleProto area = 3;
inline bool DrawElementProto::has_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.area_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_area() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.area_ != nullptr) _impl_.area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::AreaRuleProto& DrawElementProto::_internal_area() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::AreaRuleProto* p = _impl_.area_;
  return p != nullptr ? *p : reinterpret_cast<const ::AreaRuleProto&>(::_AreaRuleProto_default_instance_);
}
inline const ::AreaRuleProto& DrawElementProto::area() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.area)
  return _internal_area();
}
inline void DrawElementProto::unsafe_arena_set_allocated_area(::AreaRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.area_);
  }
  _impl_.area_ = reinterpret_cast<::AreaRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.area)
}
inline ::AreaRuleProto* DrawElementProto::release_area() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::AreaRuleProto* released = _impl_.area_;
  _impl_.area_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::AreaRuleProto* DrawElementProto::unsafe_arena_release_area() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.area)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::AreaRuleProto* temp = _impl_.area_;
  _impl_.area_ = nullptr;
  return temp;
}
inline ::AreaRuleProto* DrawElementProto::_internal_mutable_area() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.area_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::AreaRuleProto>(GetArena());
    _impl_.area_ = reinterpret_cast<::AreaRuleProto*>(p);
  }
  return _impl_.area_;
}
inline ::AreaRuleProto* DrawElementProto::mutable_area() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::AreaRuleProto* _msg = _internal_mutable_area();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.area)
  return _msg;
}
inline void DrawElementProto::set_allocated_area(::AreaRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.area_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.area_ = reinterpret_cast<::AreaRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.area)
}

// .SymbolRuleProto symbol = 4;
inline bool DrawElementProto::has_symbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.symbol_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symbol_ != nullptr) _impl_.symbol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SymbolRuleProto& DrawElementProto::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::SymbolRuleProto* p = _impl_.symbol_;
  return p != nullptr ? *p : reinterpret_cast<const ::SymbolRuleProto&>(::_SymbolRuleProto_default_instance_);
}
inline const ::SymbolRuleProto& DrawElementProto::symbol() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.symbol)
  return _internal_symbol();
}
inline void DrawElementProto::unsafe_arena_set_allocated_symbol(::SymbolRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.symbol_);
  }
  _impl_.symbol_ = reinterpret_cast<::SymbolRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.symbol)
}
inline ::SymbolRuleProto* DrawElementProto::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SymbolRuleProto* released = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::SymbolRuleProto* DrawElementProto::unsafe_arena_release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.symbol)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SymbolRuleProto* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
  return temp;
}
inline ::SymbolRuleProto* DrawElementProto::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symbol_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::SymbolRuleProto>(GetArena());
    _impl_.symbol_ = reinterpret_cast<::SymbolRuleProto*>(p);
  }
  return _impl_.symbol_;
}
inline ::SymbolRuleProto* DrawElementProto::mutable_symbol() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::SymbolRuleProto* _msg = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.symbol)
  return _msg;
}
inline void DrawElementProto::set_allocated_symbol(::SymbolRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.symbol_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.symbol_ = reinterpret_cast<::SymbolRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.symbol)
}

// .CaptionRuleProto caption = 5;
inline bool DrawElementProto::has_caption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.caption_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_caption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.caption_ != nullptr) _impl_.caption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::CaptionRuleProto& DrawElementProto::_internal_caption() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CaptionRuleProto* p = _impl_.caption_;
  return p != nullptr ? *p : reinterpret_cast<const ::CaptionRuleProto&>(::_CaptionRuleProto_default_instance_);
}
inline const ::CaptionRuleProto& DrawElementProto::caption() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.caption)
  return _internal_caption();
}
inline void DrawElementProto::unsafe_arena_set_allocated_caption(::CaptionRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.caption_);
  }
  _impl_.caption_ = reinterpret_cast<::CaptionRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.caption)
}
inline ::CaptionRuleProto* DrawElementProto::release_caption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CaptionRuleProto* released = _impl_.caption_;
  _impl_.caption_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CaptionRuleProto* DrawElementProto::unsafe_arena_release_caption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.caption)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CaptionRuleProto* temp = _impl_.caption_;
  _impl_.caption_ = nullptr;
  return temp;
}
inline ::CaptionRuleProto* DrawElementProto::_internal_mutable_caption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.caption_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CaptionRuleProto>(GetArena());
    _impl_.caption_ = reinterpret_cast<::CaptionRuleProto*>(p);
  }
  return _impl_.caption_;
}
inline ::CaptionRuleProto* DrawElementProto::mutable_caption() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::CaptionRuleProto* _msg = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.caption)
  return _msg;
}
inline void DrawElementProto::set_allocated_caption(::CaptionRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.caption_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.caption_ = reinterpret_cast<::CaptionRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.caption)
}

// .CircleRuleProto circle = 6;
inline bool DrawElementProto::has_circle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.circle_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_circle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.circle_ != nullptr) _impl_.circle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::CircleRuleProto& DrawElementProto::_internal_circle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CircleRuleProto* p = _impl_.circle_;
  return p != nullptr ? *p : reinterpret_cast<const ::CircleRuleProto&>(::_CircleRuleProto_default_instance_);
}
inline const ::CircleRuleProto& DrawElementProto::circle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.circle)
  return _internal_circle();
}
inline void DrawElementProto::unsafe_arena_set_allocated_circle(::CircleRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.circle_);
  }
  _impl_.circle_ = reinterpret_cast<::CircleRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.circle)
}
inline ::CircleRuleProto* DrawElementProto::release_circle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CircleRuleProto* released = _impl_.circle_;
  _impl_.circle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CircleRuleProto* DrawElementProto::unsafe_arena_release_circle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.circle)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CircleRuleProto* temp = _impl_.circle_;
  _impl_.circle_ = nullptr;
  return temp;
}
inline ::CircleRuleProto* DrawElementProto::_internal_mutable_circle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.circle_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::CircleRuleProto>(GetArena());
    _impl_.circle_ = reinterpret_cast<::CircleRuleProto*>(p);
  }
  return _impl_.circle_;
}
inline ::CircleRuleProto* DrawElementProto::mutable_circle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::CircleRuleProto* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.circle)
  return _msg;
}
inline void DrawElementProto::set_allocated_circle(::CircleRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.circle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.circle_ = reinterpret_cast<::CircleRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.circle)
}

// .PathTextRuleProto path_text = 7;
inline bool DrawElementProto::has_path_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_text_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_path_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.path_text_ != nullptr) _impl_.path_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::PathTextRuleProto& DrawElementProto::_internal_path_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::PathTextRuleProto* p = _impl_.path_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::PathTextRuleProto&>(::_PathTextRuleProto_default_instance_);
}
inline const ::PathTextRuleProto& DrawElementProto::path_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.path_text)
  return _internal_path_text();
}
inline void DrawElementProto::unsafe_arena_set_allocated_path_text(::PathTextRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.path_text_);
  }
  _impl_.path_text_ = reinterpret_cast<::PathTextRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.path_text)
}
inline ::PathTextRuleProto* DrawElementProto::release_path_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PathTextRuleProto* released = _impl_.path_text_;
  _impl_.path_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::PathTextRuleProto* DrawElementProto::unsafe_arena_release_path_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.path_text)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PathTextRuleProto* temp = _impl_.path_text_;
  _impl_.path_text_ = nullptr;
  return temp;
}
inline ::PathTextRuleProto* DrawElementProto::_internal_mutable_path_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.path_text_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::PathTextRuleProto>(GetArena());
    _impl_.path_text_ = reinterpret_cast<::PathTextRuleProto*>(p);
  }
  return _impl_.path_text_;
}
inline ::PathTextRuleProto* DrawElementProto::mutable_path_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::PathTextRuleProto* _msg = _internal_mutable_path_text();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.path_text)
  return _msg;
}
inline void DrawElementProto::set_allocated_path_text(::PathTextRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.path_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.path_text_ = reinterpret_cast<::PathTextRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.path_text)
}

// .ShieldRuleProto shield = 8;
inline bool DrawElementProto::has_shield() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shield_ != nullptr);
  return value;
}
inline void DrawElementProto::clear_shield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shield_ != nullptr) _impl_.shield_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::ShieldRuleProto& DrawElementProto::_internal_shield() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ShieldRuleProto* p = _impl_.shield_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShieldRuleProto&>(::_ShieldRuleProto_default_instance_);
}
inline const ::ShieldRuleProto& DrawElementProto::shield() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.shield)
  return _internal_shield();
}
inline void DrawElementProto::unsafe_arena_set_allocated_shield(::ShieldRuleProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shield_);
  }
  _impl_.shield_ = reinterpret_cast<::ShieldRuleProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DrawElementProto.shield)
}
inline ::ShieldRuleProto* DrawElementProto::release_shield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ShieldRuleProto* released = _impl_.shield_;
  _impl_.shield_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ShieldRuleProto* DrawElementProto::unsafe_arena_release_shield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:DrawElementProto.shield)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::ShieldRuleProto* temp = _impl_.shield_;
  _impl_.shield_ = nullptr;
  return temp;
}
inline ::ShieldRuleProto* DrawElementProto::_internal_mutable_shield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shield_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::ShieldRuleProto>(GetArena());
    _impl_.shield_ = reinterpret_cast<::ShieldRuleProto*>(p);
  }
  return _impl_.shield_;
}
inline ::ShieldRuleProto* DrawElementProto::mutable_shield() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::ShieldRuleProto* _msg = _internal_mutable_shield();
  // @@protoc_insertion_point(field_mutable:DrawElementProto.shield)
  return _msg;
}
inline void DrawElementProto::set_allocated_shield(::ShieldRuleProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.shield_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.shield_ = reinterpret_cast<::ShieldRuleProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:DrawElementProto.shield)
}

// repeated string apply_if = 9;
inline int DrawElementProto::_internal_apply_if_size() const {
  return _internal_apply_if().size();
}
inline int DrawElementProto::apply_if_size() const {
  return _internal_apply_if_size();
}
inline void DrawElementProto::clear_apply_if() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apply_if_.Clear();
}
inline std::string* DrawElementProto::add_apply_if() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_apply_if()->Add();
  // @@protoc_insertion_point(field_add_mutable:DrawElementProto.apply_if)
  return _s;
}
inline const std::string& DrawElementProto::apply_if(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DrawElementProto.apply_if)
  return _internal_apply_if().Get(index);
}
inline std::string* DrawElementProto::mutable_apply_if(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DrawElementProto.apply_if)
  return _internal_mutable_apply_if()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DrawElementProto::set_apply_if(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_apply_if()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:DrawElementProto.apply_if)
}
template <typename Arg_, typename... Args_>
inline void DrawElementProto::add_apply_if(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_apply_if(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:DrawElementProto.apply_if)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DrawElementProto::apply_if() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DrawElementProto.apply_if)
  return _internal_apply_if();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DrawElementProto::mutable_apply_if() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DrawElementProto.apply_if)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_apply_if();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DrawElementProto::_internal_apply_if() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apply_if_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DrawElementProto::_internal_mutable_apply_if() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.apply_if_;
}

// -------------------------------------------------------------------

// ClassifElementProto

// string name = 1;
inline void ClassifElementProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ClassifElementProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClassifElementProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClassifElementProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ClassifElementProto.name)
}
inline std::string* ClassifElementProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ClassifElementProto.name)
  return _s;
}
inline const std::string& ClassifElementProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ClassifElementProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ClassifElementProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ClassifElementProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ClassifElementProto.name)
  return _impl_.name_.Release();
}
inline void ClassifElementProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ClassifElementProto.name)
}

// repeated .DrawElementProto element = 2;
inline int ClassifElementProto::_internal_element_size() const {
  return _internal_element().size();
}
inline int ClassifElementProto::element_size() const {
  return _internal_element_size();
}
inline void ClassifElementProto::clear_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_.Clear();
}
inline ::DrawElementProto* ClassifElementProto::mutable_element(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ClassifElementProto.element)
  return _internal_mutable_element()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DrawElementProto>* ClassifElementProto::mutable_element()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ClassifElementProto.element)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_element();
}
inline const ::DrawElementProto& ClassifElementProto::element(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClassifElementProto.element)
  return _internal_element().Get(index);
}
inline ::DrawElementProto* ClassifElementProto::add_element() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::DrawElementProto* _add = _internal_mutable_element()->Add();
  // @@protoc_insertion_point(field_add:ClassifElementProto.element)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DrawElementProto>& ClassifElementProto::element() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ClassifElementProto.element)
  return _internal_element();
}
inline const ::google::protobuf::RepeatedPtrField<::DrawElementProto>&
ClassifElementProto::_internal_element() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.element_;
}
inline ::google::protobuf::RepeatedPtrField<::DrawElementProto>*
ClassifElementProto::_internal_mutable_element() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.element_;
}

// -------------------------------------------------------------------

// ColorElementProto

// string name = 1;
inline void ColorElementProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColorElementProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ColorElementProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColorElementProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ColorElementProto.name)
}
inline std::string* ColorElementProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ColorElementProto.name)
  return _s;
}
inline const std::string& ColorElementProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ColorElementProto::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ColorElementProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ColorElementProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ColorElementProto.name)
  return _impl_.name_.Release();
}
inline void ColorElementProto::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ColorElementProto.name)
}

// uint32 color = 2;
inline void ColorElementProto::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
}
inline ::uint32_t ColorElementProto::color() const {
  // @@protoc_insertion_point(field_get:ColorElementProto.color)
  return _internal_color();
}
inline void ColorElementProto::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:ColorElementProto.color)
}
inline ::uint32_t ColorElementProto::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void ColorElementProto::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// float x = 3;
inline void ColorElementProto::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float ColorElementProto::x() const {
  // @@protoc_insertion_point(field_get:ColorElementProto.x)
  return _internal_x();
}
inline void ColorElementProto::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ColorElementProto.x)
}
inline float ColorElementProto::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void ColorElementProto::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 4;
inline void ColorElementProto::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float ColorElementProto::y() const {
  // @@protoc_insertion_point(field_get:ColorElementProto.y)
  return _internal_y();
}
inline void ColorElementProto::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ColorElementProto.y)
}
inline float ColorElementProto::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void ColorElementProto::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// ColorsElementProto

// repeated .ColorElementProto value = 1;
inline int ColorsElementProto::_internal_value_size() const {
  return _internal_value().size();
}
inline int ColorsElementProto::value_size() const {
  return _internal_value_size();
}
inline void ColorsElementProto::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline ::ColorElementProto* ColorsElementProto::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ColorsElementProto.value)
  return _internal_mutable_value()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ColorElementProto>* ColorsElementProto::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ColorsElementProto.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::ColorElementProto& ColorsElementProto::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ColorsElementProto.value)
  return _internal_value().Get(index);
}
inline ::ColorElementProto* ColorsElementProto::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ColorElementProto* _add = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add:ColorsElementProto.value)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ColorElementProto>& ColorsElementProto::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ColorsElementProto.value)
  return _internal_value();
}
inline const ::google::protobuf::RepeatedPtrField<::ColorElementProto>&
ColorsElementProto::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<::ColorElementProto>*
ColorsElementProto::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// ContainerProto

// repeated .ClassifElementProto cont = 1;
inline int ContainerProto::_internal_cont_size() const {
  return _internal_cont().size();
}
inline int ContainerProto::cont_size() const {
  return _internal_cont_size();
}
inline void ContainerProto::clear_cont() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cont_.Clear();
}
inline ::ClassifElementProto* ContainerProto::mutable_cont(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ContainerProto.cont)
  return _internal_mutable_cont()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ClassifElementProto>* ContainerProto::mutable_cont()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ContainerProto.cont)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cont();
}
inline const ::ClassifElementProto& ContainerProto::cont(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ContainerProto.cont)
  return _internal_cont().Get(index);
}
inline ::ClassifElementProto* ContainerProto::add_cont() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ClassifElementProto* _add = _internal_mutable_cont()->Add();
  // @@protoc_insertion_point(field_add:ContainerProto.cont)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ClassifElementProto>& ContainerProto::cont() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ContainerProto.cont)
  return _internal_cont();
}
inline const ::google::protobuf::RepeatedPtrField<::ClassifElementProto>&
ContainerProto::_internal_cont() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cont_;
}
inline ::google::protobuf::RepeatedPtrField<::ClassifElementProto>*
ContainerProto::_internal_mutable_cont() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cont_;
}

// .ColorsElementProto colors = 2;
inline bool ContainerProto::has_colors() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.colors_ != nullptr);
  return value;
}
inline void ContainerProto::clear_colors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.colors_ != nullptr) _impl_.colors_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ColorsElementProto& ContainerProto::_internal_colors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ColorsElementProto* p = _impl_.colors_;
  return p != nullptr ? *p : reinterpret_cast<const ::ColorsElementProto&>(::_ColorsElementProto_default_instance_);
}
inline const ::ColorsElementProto& ContainerProto::colors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ContainerProto.colors)
  return _internal_colors();
}
inline void ContainerProto::unsafe_arena_set_allocated_colors(::ColorsElementProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.colors_);
  }
  _impl_.colors_ = reinterpret_cast<::ColorsElementProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ContainerProto.colors)
}
inline ::ColorsElementProto* ContainerProto::release_colors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ColorsElementProto* released = _impl_.colors_;
  _impl_.colors_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ColorsElementProto* ContainerProto::unsafe_arena_release_colors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ContainerProto.colors)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ColorsElementProto* temp = _impl_.colors_;
  _impl_.colors_ = nullptr;
  return temp;
}
inline ::ColorsElementProto* ContainerProto::_internal_mutable_colors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.colors_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::ColorsElementProto>(GetArena());
    _impl_.colors_ = reinterpret_cast<::ColorsElementProto*>(p);
  }
  return _impl_.colors_;
}
inline ::ColorsElementProto* ContainerProto::mutable_colors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ColorsElementProto* _msg = _internal_mutable_colors();
  // @@protoc_insertion_point(field_mutable:ContainerProto.colors)
  return _msg;
}
inline void ContainerProto::set_allocated_colors(::ColorsElementProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.colors_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.colors_ = reinterpret_cast<::ColorsElementProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:ContainerProto.colors)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::LineJoin> : std::true_type {};
template <>
struct is_proto_enum<::LineCap> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // drules_5fstruct_2eproto_2epb_2eh
